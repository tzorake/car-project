<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <canvas class="game-canvas"></canvas>
    <script>
        const SECOND_TO_MILLISECONDS = 1000;

        function BACKGROUND(color) 
        {
            gameCanvasContext.fillStyle = color;
            gameCanvasContext.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        const body = document.querySelector('body');
        const gameCanvas = document.querySelector('.game-canvas');
        
        gameCanvas.setAttribute('width', `${parseFloat(body.clientWidth) - 5}px`);
        gameCanvas.setAttribute('height', `${parseFloat(body.clientHeight) - 5}px`);

        const gameCanvasContext = gameCanvas.getContext('2d');

        const canvasWidth = gameCanvas.clientWidth;
        const canvasHeight = gameCanvas.clientHeight;

        class GameLoop 
        {
            #startTimeStamp = null;
            #previousTimeStamp = null;
            #done = false;

            #objects = [];

            #step = function() 
            {
                const step = function(timestamp) 
                {
                    if (this.startTimeStamp === null) 
                    {
                        this.startTimeStamp = timestamp;
                    }

                    if (this.previousTimeStamp !== null) 
                    {
                        const dt = timestamp - this.previousTimeStamp;

                        BACKGROUND('rgba(0, 0, 0, 1.0)');

                        this.#objects.forEach(object => {
                            object.update(dt);
                            object.renderer.render(object);
                        });
                    }

                    this.previousTimeStamp = timestamp;

                    if (!this.done) 
                    {
                        window.requestAnimationFrame(step);
                    }
                }.bind(this);

                window.requestAnimationFrame(step);
            }.bind(this);

            constructor(objects) 
            {
                this.#objects = objects.slice();
            }

            // `startTimeStamp` field getter & setter
            get startTimeStamp() 
            {
                return this.#startTimeStamp;
            }

            set startTimeStamp(value) 
            {
                this.#startTimeStamp = value;
            }

            // `previousTimeStamp` field getter & setter
            get previousTimeStamp() 
            {
                return this.#previousTimeStamp;
            }

            set previousTimeStamp(value) 
            {
                this.#previousTimeStamp = value;
            }

            // `done` field getter & setter
            get done() 
            {
                return this.#done;
            }

            set done(value) 
            {
                this.#done = value;
            }

            start() 
            {
                window.requestAnimationFrame(this.#step);
            }

            addObject(object) {
                if (object != undefined && !object.hasOwnProperty('update')) 
                {
                    throw new Error('GameLoop.addObject(object) : Passed object has no `update` method!');
                }

                this.#objects.push(object);
            }
        };

        class Vector2D 
        {
            #x;
            #y;

            constructor(x, y) 
            {
                this.#x = x;
                this.#y = y;
            }

            get x() 
            {
                return this.#x;
            }

            get y() 
            {
                return this.#y;
            }

            rotated(theta, c) 
            {
                c = c === undefined ? c = new Vector2D(0.0, 0.0) : c;

                return new Vector2D(
                    (this.x - c.x)*Math.cos(theta) - (this.y - c.y)*Math.sin(theta) + c.x,
                    (this.x - c.x)*Math.sin(theta) + (this.y - c.y)*Math.cos(theta) + c.y
                );
            }

            length() 
            {
                return Math.sqrt(this.x*this.x + this.y*this.y);
            }

            abs() 
            {
                return this.length();
            }

            add(...other) 
            {
                return new Vector2D(
                    this.x + other.reduce((acc, item) => acc += item.x, 0.0), 
                    this.y + other.reduce((acc, item) => acc += item.y, 0.0)
                );
            }

            multiply(other) {
                if (Vector2D.isVector2D(other)) 
                {
                    return this.x*other.x + this.y*other.y;
                }

                throw new Error('Vector2D.multiply(other) : Function argument should have `Vector2D` type!');
            }

            multiplyScalar(scalar) 
            {
                const isNumber = value => typeof value === 'number';

                if (isNumber(scalar))
                {
                    return new Vector2D(
                        scalar*this.x, 
                        scalar*this.y
                    );
                }

                throw new Error('Vector2D.multiplyScalar(scalar) : Function argument should has `Number` type!');
            }

            static isVector2D(value) 
            {
                return value instanceof Vector2D;
            }
        };

        class GameObject
        {
            #renderer;

            constructor()
            {

            }

            update(dt) 
            {
                throw new Error('GameObject: update method is not implemented yet!');
            }

            get renderer()
            {
                return this.#renderer;
            }

            set renderer(renderer)
            {
                this.#renderer = renderer;
            }


        };

        class CarObject extends GameObject 
        {
            #position;
            #width;
            #height;
            #rotation;
            #unitVector;
            #velocity;
            #engineForce;
            #dragConstant;
            #rollingResistanceConstant;
            #brakingConstant;
            #mass;
            
            #tire = new Vector2D(8.0, 20.0); // 0.2 x 0.34

            constructor(x, y, width, height) 
            {
                super();

                this.#position                  = new Vector2D(x, y);     // position of car
                this.#width                     = width;                  // width of car
                this.#height                    = height;                 // height of car
                this.#rotation                  = 0.0;                    // rotation of car
                this.#unitVector                = new Vector2D(0.0, 1.0); // unit vector (car heading direction)
                this.#velocity                  = new Vector2D(0.0, 0.0); // velocity of car
                this.#engineForce               = 1.0;
                this.#dragConstant              = 0.4257;
                this.#rollingResistanceConstant = 12.8;
                this.#brakingConstant           = 1.0;
                this.#mass                      = 1500.0;

                this.renderer = new CarRenderer();
            }

            get position() 
            {
                return this.#position;
            }

            set position(value) 
            {
                this.#position = value;
            }

            get x() 
            {
                return this.position.x;
            }

            get y() 
            {
                return this.position.y;
            }

            get width() 
            {
                return this.#width;
            }

            get height() 
            {
                return this.#height;
            }

            get rotation() 
            {
                return this.#rotation;
            }

            set rotation(value) 
            {
                this.#rotation = value;
            }

            get unitVector() 
            {
                return this.#unitVector;
            }

            get tire() 
            {
                return this.#tire;
            }

            get velocity() 
            {
                return this.#velocity;
            }

            set velocity(value) 
            {
                this.#velocity = value;
            }
            
            get engineForce() 
            {
                return this.#engineForce;
            }

            get dragConstant() 
            {
                return this.#dragConstant;
            }

            get rollingResistanceConstant() 
            {
                return this.#rollingResistanceConstant;
            }

            get mass() 
            {
                return this.#mass;
            }

            vertices() 
            {
               /*    
                *    0         1
                *      *-----*  
                *      |  |  |  
                *      |--*--|  
                *      |  |  |  
                *      *-----*  
                *    3         2
                */
                const c = this.position;
                const theta = this.rotation;
                const vertices = [
                    new Vector2D(
                        this.x - this.width/2, 
                        this.y - this.height/2
                    ),
                   
                    new Vector2D(
                        this.x + this.width/2, 
                        this.y - this.height/2
                    ),
                    
                    new Vector2D(
                        this.x + this.width/2, 
                        this.y + this.height/2
                    ),
                    
                    new Vector2D(
                        this.x - this.width/2, 
                        this.y + this.height/2
                    )
                ];
                
                return vertices.map(v => v.rotated(theta, c));
            }

            wheel(index) 
            {
                const c = this.position;
                const theta = this.rotation;
                const tire = this.tire;

                let wheel;

                switch (index) {
                    case 0: {
                        wheel = new Vector2D(
                            c.x - this.width/2, 
                            c.y - 3*this.height/10
                        );
                    } break;
                    case 1: {
                        wheel = new Vector2D(
                            c.x + this.width/2, 
                            c.y - 3*this.height/10
                        );
                    } break;
                    case 2: {
                        wheel = new Vector2D(
                            c.x + this.width/2, 
                            c.y + 3*this.height/10
                        );
                    } break;
                    case 3: {
                        wheel = new Vector2D(
                            c.x - this.width/2, 
                            c.y + 3*this.height/10
                        );
                    } break;
                    default:
                        throw new Error("CarObject.wheel(index) : Incorrect index was passed!");
                }

                return { 
                    center  : wheel,
                    vertices : [
                        new Vector2D(
                            wheel.x - tire.x/2, 
                            wheel.y - tire.y/2
                        ).rotated(theta, c),

                        new Vector2D(
                            wheel.x + tire.x/2, 
                            wheel.y - tire.y/2
                        ).rotated(theta, c),

                        new Vector2D(
                            wheel.x + tire.x/2, 
                            wheel.y + tire.y/2
                        ).rotated(theta, c),
                        
                        new Vector2D(
                            wheel.x - tire.x/2, 
                            wheel.y + tire.y/2
                        ).rotated(theta, c)
                    ]
                };
            }

            wheels() 
            {
                const indecies = [0, 1, 2, 3];
                return indecies.map(index => this.wheel(index));
            }

            update(dt) 
            {
                const time  = dt/SECOND_TO_MILLISECONDS;

                const engineForce               = this.engineForce
                const mass                      = this.mass;
                const dragConstant              = this.dragConstant;
                const rollingResistanceConstant = this.rollingResistanceConstant;

                const unitVector                = this.unitVector.rotated(this.rotation);
                const initialVelocity           = this.velocity;
                const initialPosition           = this.position;
                
                const tractionForce             = unitVector.multiplyScalar(engineForce);                              // F_traction = u / engineForce
                const dragForce                 = initialVelocity.multiplyScalar(-dragConstant*initialVelocity.abs()); // F_drag = -C_drag * v * |v|
                const rollingResistanceForce    = initialVelocity.multiplyScalar(-rollingResistanceConstant);          // F_rr = -C_rr * v

                const force                     = tractionForce.add(dragForce, rollingResistanceForce);                // F = F_traction + F_drag + F_rr
                const acceleration              = force.multiplyScalar(1.0/mass);                                      // a = F / M

                const velocity                  = initialVelocity.add(acceleration.multiplyScalar(time));              // v = v + dt * a
                this.velocity                   = velocity;

                const position                  = initialPosition.add(velocity.multiplyScalar(time));                  // p = p + dt * v
                this.position                   = position;
            }
        };

        class CarRenderer
        {
            render(car)
            {
                const vertices = car.vertices();
                const wheels = car.wheels();
                const tire = car.tire;

                gameCanvasContext.fillStyle = 'rgba(255, 0, 0, 1.0)';
                const c = new Path2D(`M ${vertices[0].x} ${vertices[0].y} L ${vertices[1].x} ${vertices[1].y} L ${vertices[2].x} ${vertices[2].y} L ${vertices[3].x} ${vertices[3].y} Z`);
                gameCanvasContext.fill(c);

                gameCanvasContext.fillStyle = 'rgba(0, 255, 0, 1.0)';
                wheels.forEach(wheel => {
                    const vertices = wheel.vertices;
                    const w = new Path2D(`M ${vertices[0].x} ${vertices[0].y} L ${vertices[1].x} ${vertices[1].y} L ${vertices[2].x} ${vertices[2].y} L ${vertices[3].x} ${vertices[3].y} Z`);
                    gameCanvasContext.fill(w);
                });
            }
        };

        const objects = [];
        
        const car = new CarObject(canvasWidth/2, canvasHeight/2, 40, 100);
        objects.push(car);

        const gameLoop = new GameLoop(objects);
        gameLoop.start();

    </script>
</body>
</html>